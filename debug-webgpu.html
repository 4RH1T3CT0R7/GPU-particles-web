<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Debug WebGPU - GPU Particles</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: monospace; }
        canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; }
        #log {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            font-size: 11px;
            z-index: 1000;
            border: 1px solid #0f0;
            border-radius: 4px;
        }
        .error { color: #f00; font-weight: bold; }
        .success { color: #0f0; }
        .warning { color: #ff0; }
        .info { color: #0af; }
        .debug { color: #888; font-size: 10px; }
        h3 { color: #0ff; margin: 10px 0 5px 0; font-size: 14px; }
        .collapsible { cursor: pointer; user-select: none; }
        .collapsible:before { content: '‚ñº '; }
        .collapsible.collapsed:before { content: '‚ñ∂ '; }
        .content { display: block; margin-left: 15px; }
        .content.collapsed { display: none; }
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border: 1px solid #0f0;
            border-radius: 4px;
            z-index: 1001;
            font-size: 11px;
        }
        #controls button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
        }
        #controls button:hover { background: #0ff; }
        #stats { color: #0af; margin-bottom: 5px; }
        .stat-error { color: #f00; }
        .stat-warning { color: #ff0; }
        .stat-success { color: #0f0; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <div id="stats">
            Errors: <span class="stat-error" id="errorCount">0</span> |
            Warnings: <span class="stat-warning" id="warningCount">0</span> |
            Success: <span class="stat-success" id="successCount">0</span>
        </div>
        <button onclick="clearLogs()">Clear Logs</button>
        <button onclick="copyLogs()">Copy Logs</button>
    </div>
    <div id="log"></div>
    <script type="module">
        const log = document.getElementById('log');
        let logCount = 0;
        const MAX_LOGS = 200; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–≥–æ–≤
        const logCache = new Map(); // –ö—ç—à –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–æ–æ–±—â–µ–Ω–∏–π

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã console –î–û –∏—Ö –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        let errorCount = 0;
        let warningCount = 0;
        let successCount = 0;

        function updateStats() {
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('warningCount').textContent = warningCount;
            document.getElementById('successCount').textContent = successCount;
        }

        window.clearLogs = function() {
            log.innerHTML = '';
            logCount = 0;
            logCache.clear();
            errorCount = 0;
            warningCount = 0;
            successCount = 0;
            updateStats();
            addLog('Logs cleared', 'info');
        };

        window.copyLogs = function() {
            const logText = Array.from(log.children)
                .filter(el => el.tagName === 'DIV' && !el.className.includes('collapsible') && !el.className.includes('content'))
                .map(el => el.textContent)
                .join('\n');

            navigator.clipboard.writeText(logText).then(() => {
                addLog('‚úì Logs copied to clipboard', 'success');
            }).catch(err => {
                addLog('‚ùå Failed to copy: ' + err.message, 'error');
            });
        };

        function addLog(msg, type = 'info') {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ
            const cacheKey = `${type}:${msg}`;
            if (logCache.has(cacheKey)) {
                const cached = logCache.get(cacheKey);
                cached.count++;

                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç
                const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                cached.element.innerHTML = `<span style="color:#666">[${timestamp}]</span> ${msg} <span style="color:#666">(√ó${cached.count})</span>`;

                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≤ –∫–æ–Ω–µ—Ü
                log.appendChild(cached.element);
                log.scrollTop = log.scrollHeight;
                return cached.element;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –ª–æ–≥–æ–≤
            if (logCount >= MAX_LOGS) {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –ª–∏–º–∏—Ç–µ (—Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑)
                if (!window.limitWarningShown) {
                    console.warn(`‚ö† Log limit reached (${MAX_LOGS}). Older logs will be removed. Use "Copy Logs" button to save current logs.`);
                    window.limitWarningShown = true;
                }

                // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π –ª–æ–≥ (—Å–∞–º—ã–π —Å—Ç–∞—Ä—ã–π)
                const firstChild = log.querySelector('div:not(h3):not(.collapsible):not(.content)');
                if (firstChild) {
                    // –£–¥–∞–ª—è–µ–º –∏–∑ –∫—ç—à–∞
                    for (let [key, value] of logCache.entries()) {
                        if (value.element === firstChild) {
                            logCache.delete(key);
                            break;
                        }
                    }
                    firstChild.remove();
                    logCount--;
                }
            }

            const div = document.createElement('div');
            div.className = type;
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            div.innerHTML = `<span style="color:#666">[${timestamp}]</span> ${msg}`;
            log.appendChild(div);
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π console.log, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏
            originalLog.call(console, `[${type.toUpperCase()}] ${msg}`);
            logCount++;

            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫—ç—à
            logCache.set(cacheKey, { element: div, count: 1 });

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if (type === 'error') errorCount++;
            else if (type === 'warning') warningCount++;
            else if (type === 'success') successCount++;
            updateStats();

            // Auto-scroll to bottom
            log.scrollTop = log.scrollHeight;

            return div;
        }

        function addSection(title) {
            const h3 = document.createElement('h3');
            h3.textContent = title;
            log.appendChild(h3);
        }

        function addCollapsible(title, content) {
            const titleDiv = document.createElement('div');
            titleDiv.className = 'collapsible';
            titleDiv.textContent = title;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';
            contentDiv.innerHTML = content;

            titleDiv.onclick = () => {
                titleDiv.classList.toggle('collapsed');
                contentDiv.classList.toggle('collapsed');
            };

            log.appendChild(titleDiv);
            log.appendChild(contentDiv);
        }

        async function testWebGPU() {
            try {
                addSection('üîç WebGPU Debug Session');
                addLog('Starting WebGPU diagnostics...', 'success');

                // Check canvas
                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    throw new Error('Canvas element not found!');
                }
                addLog('‚úì Canvas element found', 'success');

                // Check WebGPU support
                if (!navigator.gpu) {
                    throw new Error('WebGPU not supported! Your browser does not support navigator.gpu');
                }
                addLog('‚úì navigator.gpu available', 'success');

                // Request adapter
                addLog('Requesting GPU adapter...', 'info');
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('Failed to get GPU adapter! Your GPU may not support WebGPU.');
                }
                addLog('‚úì GPU adapter obtained', 'success');

                // Log adapter info (optional - newer WebGPU API)
                if (typeof adapter.requestAdapterInfo === 'function') {
                    try {
                        const adapterInfo = await adapter.requestAdapterInfo();
                        addCollapsible('Adapter Info', `
                            <div class="debug">Vendor: ${adapterInfo.vendor || 'Unknown'}</div>
                            <div class="debug">Architecture: ${adapterInfo.architecture || 'Unknown'}</div>
                            <div class="debug">Device: ${adapterInfo.device || 'Unknown'}</div>
                            <div class="debug">Description: ${adapterInfo.description || 'Unknown'}</div>
                        `);
                    } catch (err) {
                        addLog('‚ö† Could not get adapter info: ' + err.message, 'warning');
                    }
                } else {
                    addLog('‚ö† adapter.requestAdapterInfo() not available (older WebGPU version)', 'warning');
                    addCollapsible('Adapter Info', `
                        <div class="debug">requestAdapterInfo() not supported in this browser version</div>
                        <div class="debug">Consider updating to latest Chrome Canary for full diagnostics</div>
                    `);
                }

                // Log adapter features
                const features = Array.from(adapter.features);
                addCollapsible('Adapter Features (' + features.length + ')',
                    features.map(f => `<div class="debug">‚Ä¢ ${f}</div>`).join('')
                );

                // Log adapter limits
                const limits = adapter.limits;
                const importantLimits = [
                    'maxTextureDimension2D',
                    'maxBufferSize',
                    'maxStorageBufferBindingSize',
                    'maxComputeWorkgroupsPerDimension',
                    'maxComputeInvocationsPerWorkgroup'
                ];
                addCollapsible('Adapter Limits',
                    importantLimits.map(l => `<div class="debug">${l}: ${limits[l]}</div>`).join('')
                );

                // Request device
                addLog('Requesting GPU device...', 'info');
                const device = await adapter.requestDevice();
                addLog('‚úì GPU device obtained', 'success');

                // Setup error handling
                device.addEventListener('uncapturederror', (event) => {
                    addLog('‚ùå WebGPU uncaptured error: ' + event.error.constructor.name, 'error');
                    addLog('   ' + event.error.message, 'error');
                });

                device.lost.then((info) => {
                    addLog('‚ùå Device lost! Reason: ' + info.reason, 'error');
                    addLog('   Message: ' + info.message, 'error');
                });

                // Test shader compilation
                addSection('üîß Testing Shader Compilation');

                const testShaderCode = `
                    @compute @workgroup_size(64)
                    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                        // Test compute shader
                    }
                `;

                try {
                    const testModule = device.createShaderModule({
                        label: 'Test Shader',
                        code: testShaderCode
                    });
                    addLog('‚úì Test compute shader compiled', 'success');
                } catch (err) {
                    addLog('‚ùå Test shader failed: ' + err.message, 'error');
                }

                // Test shader loading from files
                addSection('üìÇ Testing Shader File Loading');

                const shaderFiles = [
                    './src/shaders-wgsl/particle-sim.wgsl',
                    './src/shaders-wgsl/bvh-simple.wgsl',
                    './src/shaders-wgsl/ray-trace.wgsl',
                    './src/shaders-wgsl/temporal-accumulation.wgsl',
                    './src/shaders-wgsl/blit.wgsl'
                ];

                for (const file of shaderFiles) {
                    try {
                        addLog(`Loading ${file}...`, 'info');
                        const response = await fetch(file);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const shaderCode = await response.text();

                        // Check if it's actually WGSL (not HTML error page)
                        if (shaderCode.includes('<!DOCTYPE') || shaderCode.includes('<html')) {
                            throw new Error('Received HTML instead of WGSL shader code (404 error page)');
                        }

                        addLog(`  ‚úì Fetched (${shaderCode.length} chars)`, 'success');

                        // Try to compile it
                        try {
                            const shaderModule = device.createShaderModule({
                                label: file.split('/').pop(),
                                code: shaderCode
                            });

                            // Wait for compilation
                            const compilationInfo = await shaderModule.getCompilationInfo();

                            let hasErrors = false;
                            for (const message of compilationInfo.messages) {
                                if (message.type === 'error') {
                                    hasErrors = true;
                                    addLog(`  ‚ùå Line ${message.lineNum}: ${message.message}`, 'error');
                                } else if (message.type === 'warning') {
                                    addLog(`  ‚ö† Line ${message.lineNum}: ${message.message}`, 'warning');
                                }
                            }

                            if (!hasErrors) {
                                addLog(`  ‚úì Compiled successfully`, 'success');
                            }
                        } catch (compileErr) {
                            addLog(`  ‚ùå Compilation error: ${compileErr.message}`, 'error');
                        }

                    } catch (err) {
                        addLog(`  ‚ùå Failed: ${err.message}`, 'error');
                    }
                }

                // Test context configuration
                addSection('üñºÔ∏è Testing Canvas Context');

                const context = canvas.getContext('webgpu');
                if (!context) {
                    throw new Error('Failed to get WebGPU context from canvas!');
                }
                addLog('‚úì WebGPU context obtained', 'success');

                const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
                addLog(`  Preferred format: ${canvasFormat}`, 'info');

                context.configure({
                    device: device,
                    format: canvasFormat,
                    alphaMode: 'premultiplied',
                });
                addLog('‚úì Context configured', 'success');

                // Now load the actual application
                addSection('üöÄ Loading WebGPU Application');
                addLog('Importing index-webgpu.js...', 'info');

                // Override console methods to capture logs
                console.log = (...args) => {
                    addLog(args.join(' '), 'debug');
                };

                console.error = (...args) => {
                    addLog(args.join(' '), 'error');
                };

                console.warn = (...args) => {
                    addLog(args.join(' '), 'warning');
                };

                try {
                    await import('./index-webgpu.js');
                    addLog('‚úì Application module loaded', 'success');
                } catch (err) {
                    addLog('‚ùå Application failed: ' + err.message, 'error');
                    addLog('Stack trace:', 'error');
                    const stack = err.stack.split('\n');
                    stack.forEach(line => addLog('  ' + line, 'error'));
                }

            } catch (err) {
                addLog('‚ùå FATAL ERROR: ' + err.message, 'error');
                addLog('Stack trace:', 'error');
                const stack = err.stack.split('\n');
                stack.forEach(line => addLog('  ' + line, 'error'));
            }
        }

        // Capture all errors
        window.addEventListener('error', (e) => {
            addLog('‚ùå Runtime error: ' + e.message, 'error');
            addLog('  at ' + e.filename + ':' + e.lineno + ':' + e.colno, 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            addLog('‚ùå Unhandled promise rejection: ' + e.reason, 'error');
            if (e.reason && e.reason.stack) {
                addLog('  ' + e.reason.stack, 'error');
            }
        });

        // Start the test
        testWebGPU();
    </script>
</body>
</html>
