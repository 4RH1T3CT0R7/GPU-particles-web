<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'" />
    <title>Debug WebGPU - GPU Particles</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: monospace; }
        canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; }
        #log {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            font-size: 11px;
            z-index: 1000;
            border: 1px solid #0f0;
            border-radius: 4px;
        }
        .error { color: #f00; font-weight: bold; }
        .success { color: #0f0; }
        .warning { color: #ff0; }
        .info { color: #0af; }
        .debug { color: #888; font-size: 10px; }
        h3 { color: #0ff; margin: 10px 0 5px 0; font-size: 14px; }
        .collapsible { cursor: pointer; user-select: none; }
        .collapsible:before { content: '‚ñº '; }
        .collapsible.collapsed:before { content: '‚ñ∂ '; }
        .content { display: block; margin-left: 15px; }
        .content.collapsed { display: none; }
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border: 1px solid #0f0;
            border-radius: 4px;
            z-index: 1001;
            font-size: 11px;
        }
        #controls button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
        }
        #controls button:hover { background: #0ff; }
        #stats { color: #0af; margin-bottom: 5px; }
        .stat-error { color: #f00; }
        .stat-warning { color: #ff0; }
        .stat-success { color: #0f0; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <div id="stats">
            Errors: <span class="stat-error" id="errorCount">0</span> |
            Warnings: <span class="stat-warning" id="warningCount">0</span> |
            Success: <span class="stat-success" id="successCount">0</span>
        </div>
        <button onclick="clearLogs()">Clear Logs</button>
        <button onclick="copyLogs()">Copy Logs</button>
    </div>
    <div id="log"></div>
    <script type="module">
        const log = document.getElementById('log');
        let logCount = 0;
        const MAX_LOGS = 200; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–≥–æ–≤
        const MAX_REPEAT_COUNT = 1000; // –ú–∞–∫—Å–∏–º—É–º –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π –æ–¥–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        const logCache = new Map(); // –ö—ç—à –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–æ–æ–±—â–µ–Ω–∏–π

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã console –î–û –∏—Ö –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        let errorCount = 0;
        let warningCount = 0;
        let successCount = 0;

        function updateStats() {
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('warningCount').textContent = warningCount;
            document.getElementById('successCount').textContent = successCount;
        }

        window.clearLogs = function() {
            log.textContent = '';
            logCount = 0;
            logCache.clear();
            errorCount = 0;
            warningCount = 0;
            successCount = 0;
            updateStats();
            addLog('Logs cleared', 'info');
        };

        window.copyLogs = function() {
            const logText = Array.from(log.children)
                .filter(el => el.tagName === 'DIV' && !el.className.includes('collapsible') && !el.className.includes('content'))
                .map(el => el.textContent)
                .join('\n');

            navigator.clipboard.writeText(logText).then(() => {
                addLog('‚úì Logs copied to clipboard', 'success');
            }).catch(err => {
                addLog('‚ùå Failed to copy: ' + err.message, 'error');
            });
        };

        function addLog(msg, type = 'info') {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ
            const cacheKey = `${type}:${msg}`;
            if (logCache.has(cacheKey)) {
                const cached = logCache.get(cacheKey);
                cached.count++;

                // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä–∏–ª–æ—Å—å —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Ä–∞–∑, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º warning –∏ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
                if (cached.count === MAX_REPEAT_COUNT) {
                    const ts0 = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    cached.element.textContent = '';
                    const tsSpan0 = document.createElement('span'); tsSpan0.style.color = '#666'; tsSpan0.textContent = `[${ts0}] `;
                    const stopSpan = document.createElement('span'); stopSpan.style.color = '#f00'; stopSpan.textContent = ` (\u00d7${cached.count} - STOPPED)`;
                    cached.element.append(tsSpan0, msg, stopSpan);
                    log.appendChild(cached.element);
                    originalWarn.call(console, `‚ö† Message repeated ${MAX_REPEAT_COUNT} times, stopping further updates:`, msg);
                    return cached.element;
                } else if (cached.count > MAX_REPEAT_COUNT) {
                    // –ü—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è, –Ω–µ –æ–±–Ω–æ–≤–ª—è—è DOM
                    return cached.element;
                }

                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç
                const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                cached.element.textContent = '';
                const tsSpan1 = document.createElement('span'); tsSpan1.style.color = '#666'; tsSpan1.textContent = `[${timestamp}] `;
                const countSpan = document.createElement('span'); countSpan.style.color = '#666'; countSpan.textContent = ` (\u00d7${cached.count})`;
                cached.element.append(tsSpan1, msg, countSpan);

                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≤ –∫–æ–Ω–µ—Ü
                log.appendChild(cached.element);
                log.scrollTop = log.scrollHeight;
                return cached.element;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –ª–æ–≥–æ–≤
            if (logCount >= MAX_LOGS) {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –ª–∏–º–∏—Ç–µ (—Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑)
                if (!window.limitWarningShown) {
                    console.warn(`‚ö† Log limit reached (${MAX_LOGS}). Older logs will be removed. Use "Copy Logs" button to save current logs.`);
                    window.limitWarningShown = true;
                }

                // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π –ª–æ–≥ (—Å–∞–º—ã–π —Å—Ç–∞—Ä—ã–π)
                const firstChild = log.querySelector('div:not(h3):not(.collapsible):not(.content)');
                if (firstChild) {
                    // –£–¥–∞–ª—è–µ–º –∏–∑ –∫—ç—à–∞
                    for (let [key, value] of logCache.entries()) {
                        if (value.element === firstChild) {
                            logCache.delete(key);
                            break;
                        }
                    }
                    firstChild.remove();
                    logCount--;
                }
            }

            const div = document.createElement('div');
            div.className = type;
            const timestamp2 = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const tsSpan2 = document.createElement('span'); tsSpan2.style.color = '#666'; tsSpan2.textContent = `[${timestamp2}] `;
            div.append(tsSpan2, msg);
            log.appendChild(div);
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π console.log, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏
            originalLog.call(console, `[${type.toUpperCase()}] ${msg}`);
            logCount++;

            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫—ç—à
            logCache.set(cacheKey, { element: div, count: 1 });

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if (type === 'error') errorCount++;
            else if (type === 'warning') warningCount++;
            else if (type === 'success') successCount++;
            updateStats();

            // Auto-scroll to bottom
            log.scrollTop = log.scrollHeight;

            return div;
        }

        function addSection(title) {
            const h3 = document.createElement('h3');
            h3.textContent = title;
            log.appendChild(h3);
        }

        function addCollapsible(title, lines) {
            const titleDiv = document.createElement('div');
            titleDiv.className = 'collapsible';
            titleDiv.textContent = title;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';
            for (const line of lines) {
                const d = document.createElement('div');
                d.className = 'debug';
                d.textContent = line;
                contentDiv.appendChild(d);
            }

            titleDiv.onclick = () => {
                titleDiv.classList.toggle('collapsed');
                contentDiv.classList.toggle('collapsed');
            };

            log.appendChild(titleDiv);
            log.appendChild(contentDiv);
        }

        async function testWebGPU() {
            try {
                addSection('üîç WebGPU Debug Session');
                addLog('Starting WebGPU diagnostics...', 'success');

                // Check canvas
                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    throw new Error('Canvas element not found!');
                }
                addLog('‚úì Canvas element found', 'success');

                // Check WebGPU support
                if (!navigator.gpu) {
                    throw new Error('WebGPU not supported! Your browser does not support navigator.gpu');
                }
                addLog('‚úì navigator.gpu available', 'success');

                // Request adapter
                addLog('Requesting GPU adapter...', 'info');
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('Failed to get GPU adapter! Your GPU may not support WebGPU.');
                }
                addLog('‚úì GPU adapter obtained', 'success');

                // Log adapter info (optional - newer WebGPU API)
                if (typeof adapter.requestAdapterInfo === 'function') {
                    try {
                        const adapterInfo = await adapter.requestAdapterInfo();
                        addCollapsible('Adapter Info', [
                            `Vendor: ${adapterInfo.vendor || 'Unknown'}`,
                            `Architecture: ${adapterInfo.architecture || 'Unknown'}`,
                            `Device: ${adapterInfo.device || 'Unknown'}`,
                            `Description: ${adapterInfo.description || 'Unknown'}`
                        ]);
                    } catch (err) {
                        addLog('‚ö† Could not get adapter info: ' + err.message, 'warning');
                    }
                } else {
                    addLog('‚ö† adapter.requestAdapterInfo() not available (older WebGPU version)', 'warning');
                    addCollapsible('Adapter Info', [
                        'requestAdapterInfo() not supported in this browser version',
                        'Consider updating to latest Chrome Canary for full diagnostics'
                    ]);
                }

                // Log adapter features
                const features = Array.from(adapter.features);
                addCollapsible('Adapter Features (' + features.length + ')',
                    features.map(f => `\u2022 ${f}`)
                );

                // Log adapter limits
                const limits = adapter.limits;
                const importantLimits = [
                    'maxTextureDimension2D',
                    'maxBufferSize',
                    'maxStorageBufferBindingSize',
                    'maxComputeWorkgroupsPerDimension',
                    'maxComputeInvocationsPerWorkgroup'
                ];
                addCollapsible('Adapter Limits',
                    importantLimits.map(l => `${l}: ${limits[l]}`)
                );

                // Request device
                addLog('Requesting GPU device...', 'info');
                const device = await adapter.requestDevice();
                addLog('‚úì GPU device obtained', 'success');

                // Setup error handling with emergency stop
                let errorCount = 0;
                const MAX_ERRORS = 10;

                device.addEventListener('uncapturederror', (event) => {
                    const error = event.error;
                    // Combine into single message for better deduplication
                    addLog('‚ùå WebGPU uncaptured error: ' + error.constructor.name + ' - ' + error.message, 'error');

                    // Emergency stop after too many errors
                    errorCount++;
                    if (errorCount >= MAX_ERRORS) {
                        addLog('üö® EMERGENCY STOP: Too many errors. Page load stopped to prevent crash.', 'error');
                        addLog('üö® Please do HARD REFRESH: Ctrl+Shift+R (Windows) or Cmd+Shift+R (Mac)', 'error');
                        throw new Error('Emergency stop to prevent GPU crash');
                    }
                });

                device.lost.then((info) => {
                    addLog('‚ùå Device lost! Reason: ' + info.reason, 'error');
                    addLog('   Message: ' + info.message, 'error');
                });

                // Test shader compilation
                addSection('üîß Testing Shader Compilation');

                const testShaderCode = `
                    @compute @workgroup_size(64)
                    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                        // Test compute shader
                    }
                `;

                try {
                    const testModule = device.createShaderModule({
                        label: 'Test Shader',
                        code: testShaderCode
                    });
                    addLog('‚úì Test compute shader compiled', 'success');
                } catch (err) {
                    addLog('‚ùå Test shader failed: ' + err.message, 'error');
                }

                // Note: WGSL shaders are now bundled inline via TypeScript (src/wgsl/shaders.ts)
                // The .wgsl files no longer exist ‚Äî shaders are compiled at pipeline init time
                addLog('‚Ñπ WGSL shaders are bundled inline (no separate .wgsl files)', 'info');

                // Test context configuration
                addSection('üñºÔ∏è Testing Canvas Context');

                const context = canvas.getContext('webgpu');
                if (!context) {
                    throw new Error('Failed to get WebGPU context from canvas!');
                }
                addLog('‚úì WebGPU context obtained', 'success');

                const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
                addLog(`  Preferred format: ${canvasFormat}`, 'info');

                context.configure({
                    device: device,
                    format: canvasFormat,
                    alphaMode: 'premultiplied',
                });
                addLog('‚úì Context configured', 'success');

                // Now load the actual application
                addSection('üöÄ Loading WebGPU Application');
                addLog('Importing index-webgpu.js...', 'info');

                // Override console methods to capture logs
                console.log = (...args) => {
                    addLog(args.join(' '), 'debug');
                };

                console.error = (...args) => {
                    addLog(args.join(' '), 'error');
                };

                console.warn = (...args) => {
                    addLog(args.join(' '), 'warning');
                };

                try {
                    await import('./dist/index-webgpu.js');
                    addLog('‚úì Application module loaded', 'success');
                } catch (err) {
                    addLog('‚ùå Application failed: ' + err.message, 'error');
                    addLog('Stack trace:', 'error');
                    const stack = err.stack.split('\n');
                    stack.forEach(line => addLog('  ' + line, 'error'));
                }

            } catch (err) {
                addLog('‚ùå FATAL ERROR: ' + err.message, 'error');
                addLog('Stack trace:', 'error');
                const stack = err.stack.split('\n');
                stack.forEach(line => addLog('  ' + line, 'error'));
            }
        }

        // Capture all errors
        window.addEventListener('error', (e) => {
            addLog('‚ùå Runtime error: ' + e.message, 'error');
            addLog('  at ' + e.filename + ':' + e.lineno + ':' + e.colno, 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            addLog('‚ùå Unhandled promise rejection: ' + e.reason, 'error');
            if (e.reason && e.reason.stack) {
                addLog('  ' + e.reason.stack, 'error');
            }
        });

        // Start the test
        testWebGPU();
    </script>
</body>
</html>
